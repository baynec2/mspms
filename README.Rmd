---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  cache = FALSE
)
```

# mspms

<!-- badges: start -->
[![R-CMD-check](https://github.com/baynec2/mspms/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/baynec2/mspms/actions/workflows/R-CMD-check.yaml)
[![Codecov test coverage](https://codecov.io/gh/baynec2/mspms/branch/main/graph/badge.svg)](https://app.codecov.io/gh/baynec2/mspms?branch=main)
<!-- badges: end -->

The goal of mspms is provide a concise code-base for the normalization and data processing required to analyze data from the [Multiplex Substrate Profiling by Mass Spectrometry (MSP-MS) method](https://pubmed.ncbi.nlm.nih.gov/36948708/). 


Additionally, we provide a [graphical user interface powered by shiny apps](https://gonzalezlab.shinyapps.io/mspms_shiny/) that allows for a user to utilize the method without requiring any R coding knowledge. 



## Installation


You can install the released version of mspms from github

```{r,eval = FALSE}
devtools::install_github("baynec2/mspms")
```

## Overview

There are 4 different types of functions in this package.  Those that are involved in: 

1. Making mspms generically useful. These functions are focused on making mspms more generally useful to a wider audience outside of the very specific workflow traditionally used in the Oâ€™Donoghue lab. Allows for the use of other types of upstream proteomic data processing, different peptide libraries, etc.    

2. Data processing/ normalization. These functions allow the user to normalize and process the MSP-MS data.    

3. Statistics. These methods allow the user to perform basic statistics on the normalyzed/processed data.   

4. Data visualization. These functions allow the user to visualize the data in a number of useful way. 


**Making mspms generically useful**.   
1. *prepare_peaks()*:Takes two input files from PEAKS and combines them. 
2. *prepare_pd()*: prepares exported files from proteome discoverer.  
3. *extract_design_matrix_pd()*: Extracts the design matrix from the proteome discoverer file.  
4. *prepare_spectronaut()*: prepares exported files from spectronaut - note in development, not yet implemented.  
5. *calculate_all_cleavages()*: Calculates all possible cleavages for peptide library sequences. 

**Data Proessing/ Normalization**.  
1. *normalyze()*: Normalizes values.     
2. *handle_outliers()*: Looks for outliers across replicates. Removes them.       
3. *impute()*: Imputes data for missing values (not including NAs introduced by handle_outliers()).    
4. *join_with_library()*: Joins the normalyzed data with the peptide library sequences.  
5. *add_cleavages()*: Figures out the locations of the detected clevages within the library of peptide sequences used. Is it cleaved at the N or C terminus, or both?  Uses *cterm_cleavage()* and *nterm_cleavage()* to do this.    
6. *polish()*: combines the cleavage info into one column. Discards peptides that were cleaved on both sides or not at all.  
7. *prepare_for_stats()*: Reshapes the data into a long format and appends the data in the design matrix to make statistical testing easy to perform.  

**Statistics**.   
1. *log2fc_t_test()*: Calculates the fold change and the p/q value across experimental conditions using T-tests.      
2. *mspms_anova()*: Conducts ANOVA tests to determine if there are any peptides that are significantly different across all time points.      

**Data Visualization**.   
1. *plot_heatmap()*: Conducts hierarchical clustering analysis and plots an interactive heatmap to visualize overall patterns in the data.    
2. *plot_pca()*: PCA analysis to visualize the data in a 2D space.  
3. *plot_time_course()*: Plot peptides over time by condition.  
4. *plot_icelogo()*: Visualize the sequence specificity of the cleavage sites. Designed to be equivalent to what is implemented in IceLogo.   


## Making Generically Usefull. 


### Formating Peaks File Outputs. 

All analysis performed by this package is downstream of the data generated by the PEAKS software. The first step is to combine the two files generated by PEAKS.  

The files coming from peaks should be generated according to the instructions found [here](www/PeaksDataAnalysis_howto.pdf).  


```{r}
library(dplyr)
library(mspms)

### Loading the files ###
lfq_filename = "tests/testdata/protein-peptides-lfq.csv"
#file "protein-peptides.csv" exported from PEAKS identification
id_filename = "tests/testdata/protein-peptides-id.csv"

# Prepare the data for normalyzer analysis
peaks_prepared_data = prepare_peaks(lfq_filename,id_filename)


# saving to data folder in package for tests. Ignore when using on your own data
usethis::use_data(peaks_prepared_data,overwrite = TRUE)
```


### Formating Proteome Discoverer File Outputs.

We can prepare proteome discover files for analysis with mspms as follows.

```{r}
prepared_proteome_discoverer = prepare_pd("tests/testdata/proteome_discoverer_output.xlsx")
```


We can also extract a design matrix from the naming scheme used by proteome discoverer as follows.

```{r}
 design_matrix = extract_design_matrix_pd("tests/testdata/proteome_discoverer_output.xlsx")
```

### Calculating all cleavages

We might want to calculate all possible cleavages for the peptide library sequences. This is useful for downstream analysis, especially when we are looking at the specificity of the cleavage sites via plot_cleavage_motif() as this requires a background of all possible cleavages

We can do this by specifying the number of amino acids after the cleavage site that we are interested in. First lets try 4, which is the default. 

```{r}
all_peptide_sequences = mspms::calculate_all_cleavages(mspms::peptide_library$library_real_sequence,
                        n_AA_after_cleavage=4)
head(all_peptide_sequences)

```

We could also try 5 AA after each cleavage site 

```{r}
all_peptide_sequences = mspms::calculate_all_cleavages(mspms::peptide_library$library_real_sequence,
                        n_AA_after_cleavage=5)
head(all_peptide_sequences)
```




## Data Normalization/ Processing 




### Loading design matrix

Before we normalyze data, we need to know what samples are in what groups. We can do that by defining a design matrix. 
```{r}
design_matrix = readr::read_csv("tests/testdata/design_matrix.csv")

head(design_matrix)

```
### Normalyzing data

mspms uses the NormalyzerDE package to do normalization under the hood. 

We can normalyze the data as follows:  
```{r}
normalyzed_data = normalyze(peaks_prepared_data,design_matrix)

# saving to data folder in package for tests. Ignore when using on your own data
usethis::use_data(normalyzed_data,overwrite = TRUE)
```

### Handling Outliers

Here we use a dixon test from the outliers package to detect outliers from each of our replicates. We need to know what samples are part of which groups, so we need to specify the design matrix here too. Make sure that the column header names are "sample" and "group" just like before.

```{r}
design_matrix = readr::read_csv("tests/testdata/design_matrix.csv")
outliers = handle_outliers(normalyzed_data,design_matrix)

# saving to data folder in package for tests. Ignore when using on your own data
usethis::use_data(outliers,overwrite = TRUE)
```

### Imputation of data 

We have a lot of missing, or 0 values. For these, we need to impute them so we can do downstream statistics. 

```{r}
imputed = impute(outliers)

# saving to data folder in package for tests. Ignore when using on your own data
usethis::use_data(imputed,overwrite = TRUE)
```


### Joining with Library

Next we need to join everything with the sequences of the peptide library.  
```{r}
joined_with_library = join_with_library(imputed)

# saving to data folder in package for tests. Ignore when using on your own data
usethis::use_data(joined_with_library,overwrite = TRUE)
```



### Calcuating cleavages. 

Next, we need to determine where the peptide sequences are cleaved. 

We check both the N and C terminus. 

Sequences are presented as the user specified number of amino acids on both sides of a cleavage. The default is 4, but there is interest in looking at motifs that are farther away from the cut site. Note that X indicates that there was nothing on that side in the library because it was cleaved close to the edge. 

```{r}
cleavage_added_data = add_cleavages(joined_with_library,n_residues = 4)

head(cleavage_added_data)

# saving to data folder in package for tests. Ignore when using on your own data
usethis::use_data(cleavage_added_data,overwrite = TRUE)
```

### Polishing

Someimes there is a need to polish the data a bit for downstream analysis. This function does that by removing combining the cterm and nterm cleavage information into one column while removing any rows that don't have any cleavage information or have cleavage information on the cterm and nterm.

```{r}
polished_data = polish(cleavage_added_data)
```



## Statistics

mspms provides a number of convenience functions to conduct statistics on the data. 


First, we need to prepare the data for stats. This involves reshaping the data into the long format so it is easy to conduct statistics on and then appending the data in the design matrix that allows us to determine what sample contains what conditions/time and conduct the appropriate statistics. 

```{r}
prepared_for_stats = prepare_for_stats(cleavage_added_data,design_matrix)

usethis::use_data(prepared_for_stats,overwrite = TRUE)
```

Noe we can conduct the statistics.

### T tests

Ttests are performed within each condition and compared to time 0.

For example, for an experiment where there are two conditions, DMSO and MZB as well as 3 time points, 0, 1, and 2, the t tests would be as follows:

* DMSO.TO vs DMSO.T0. 
* DMSO.T0 vs DMSO.T1. 
* DMSO.T0 vs DMSO.T2. 

* MZB.T0 vs MZB.T0. 
* MZB.T0 vs MZB.T1. 
* MZB.T0 vs MZB.T2. 

```{r}
# Perform T test
t_test_stats = mspms::mspms_t_tests(prepared_for_stats)
```

### log2FC

We can also calculate the log 2 fold change. The comparisons here are the same as for the T tests.  
```{r}
# calclulate log2fc
log2fc = mspms::mspms_log2fc(prepared_for_stats)

head(log2fc)
```


### log2fc_t_tests.  

Sometimes (such as when you want to make volcano plots) it is useful to look at the log2fc and the t test statistics at the same time. This function does that.  

```{r}
log2fc_t_test = mspms::log2fc_t_test(prepared_for_stats)

head(log2fc_t_test)
```


Now that we have this data we can visualize these results easily using the ggplot2 package as follows.   

```{r}
library(ggplot2)

p1 = log2fc_t_test %>% 
  ggplot(aes(x = log2fc,y = -log10(p.adj)))+
  geom_point(size =0.5)+
  geom_hline(yintercept = -log10(0.05),linetype = "dashed",color = "red")+
  geom_vline(xintercept = 3, linetype = "dashed",color = "red")+
  geom_vline(xintercept = -3, linetype = "dashed",color = "red")+
  theme_minimal()+
  labs(x = "Log2 Fold Change",y = "-log10(p value)")+
  facet_wrap(~comparison,scales = "free")

p1
```

### ANOVA

We also might want to perfom an anova. Here, we have it set up to show the effect of time within each condition. 

For example, for an experiment where there are two conditions, DMSO and MZB as well as 3 time points, 0, 1, and 2, the anova would statistics for the effect of time for each peptide within DMSO or MZB. 

```{r}
# Doing ANOVA
anova_stats = mspms::mspms_anova(prepared_for_stats)

head(anova_stats)
```

## Common Data Visualizations

We also provide some functions that make common data visualizations easier.


### Plotting sequence specificity motif

Here use an approach similar to what is implemented in ICELogo to visualize the sequence specificity of the cleavage sites. This was used as reference to build the code: https://iomics.ugent.be/icelogoserver/resources/manual.pdf. 

```{r}
cleavage_seqs = mspms::prepared_for_stats %>%
  mspms::polish() %>% 
  filter(condition == "DMSO",time == 240) %>%
  pull(cleavage_seq)

background_universe = mspms::all_possible_8mers_from_228_library


mspms::plot_icelogo(cleavage_seqs,background_universe)
```

### PCA 

We can generate a PCA plot to visualize the data. Here, the colors show the different time points while the shape shows the different conditions.  

```{r}
mspms::plot_pca(prepared_for_stats)
```

### Hierchical clustering

We can also generate an interactive heatmap with the hierchical clustering results. 

The format of this readme does not allow for interactivity, so a static picture of the output is shown instead. 

```{r,eval = FALSE}

mspms::plot_heatmap(prepared_for_stats)

```

![](plot_heatmap_output.png)
  
### Ploting time course.  

We also provide a function for plotting the mean intensity and standard deviation over time for each peptide in the data set by conditions. Facets show peptide, color shows the condition. 

This is best used in combination with the ANOVA function. Below, we will use anova to calculate the peptides where we see an effect of time (in the DMSO group), and then plot these.

```{r}

top10sig = anova_stats %>% 
  arrange(p.adj) %>%
  pull(Peptide) %>% 
  head(10)


p1 = prepared_for_stats %>%
  dplyr::filter(Peptide %in% top10sig) %>%
  mspms::plot_time_course()

p1
```

